---
title: SQLSetStmtAttr, fonction | Microsoft Docs
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLSetStmtAttr
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLSetStmtAttr
helpviewer_keywords:
- SQLSetStmtAttr function [ODBC]
ms.assetid: 7abc5260-733a-48d4-9974-2d1a6a9ea5f6
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: dda856d0381b6e9ca8f5a8c9625151c148435edb
ms.sourcegitcommit: 61381ef939415fe019285def9450d7583df1fed0
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/01/2018
ms.locfileid: "47746427"
---
# <a name="sqlsetstmtattr-function"></a>Fonction SQLSetStmtAttr
**Conformité**  
 Version introduite : Conformité des normes 3.0 de ODBC : ISO 92  
  
 **Résumé**  
 **SQLSetStmtAttr** définit les attributs liés à une instruction.  
  
> [!NOTE]  
>  Pour plus d’informations sur ce que le Gestionnaire de pilotes mappe cette fonction lorsqu’un ODBC 3 *.x* application fonctionne avec un ODBC 2 *.x* pilote, consultez [mappage des fonctions de remplacement pour vers l’arrière Compatibilité des Applications](../../../odbc/reference/develop-app/mapping-replacement-functions-for-backward-compatibility-of-applications.md).  
  
## <a name="syntax"></a>Syntaxe  
  
```  
  
SQLRETURN SQLSetStmtAttr(  
     SQLHSTMT      StatementHandle,  
     SQLINTEGER    Attribute,  
     SQLPOINTER    ValuePtr,  
     SQLINTEGER    StringLength);  
```  
  
## <a name="arguments"></a>Arguments  
 *Au paramètre StatementHandle*  
 [Entrée] Descripteur d’instruction.  
  
 *Attribute*  
 [Entrée] Option permettant de définir, répertoriés dans « Commentaires ».  
  
 *ValuePtr*  
 [Entrée] Valeur à associer à *attribut*. Selon la valeur de *attribut*, *ValuePtr* aura l’une des opérations suivantes :  
  
-   Un handle de descripteur ODBC.  
  
-   Une valeur SQLUINTEGER.  
  
-   Une valeur SQLULEN.  
  
-   Pointeur vers une des opérations suivantes :  
  
    -   Chaîne de caractères se terminant par null.  
  
    -   Une mémoire tampon binaire.  
  
    -   Une valeur ou un tableau de type SQLLEN, SQLULEN ou SQLUSMALLINT.  
  
    -   Une valeur définie par le pilote.  
  
 Si le *attribut* argument est une valeur spécifique au pilote, *ValuePtr* peut être un entier signé.  
  
 *StringLength*  
 [Entrée] Si *attribut* est un attribut défini par ODBC et *ValuePtr* pointe vers une chaîne de caractères ou une mémoire tampon binaire, cet argument doit être la longueur de \* *ValuePtr*. Si *attribut* est un attribut défini par ODBC et *ValuePtr* est un entier, *StringLength* est ignoré.  
  
 Si *attribut* est un attribut définies par le pilote, l’application indique la nature de l’attribut pour le Gestionnaire de pilotes en définissant le *StringLength* argument. *StringLength* peut avoir les valeurs suivantes :  
  
-   Si *ValuePtr* est un pointeur vers une chaîne de caractères, puis *StringLength* est la longueur de la chaîne ou le SQL_NTS.  
  
-   Si *ValuePtr* est un pointeur vers une mémoire tampon binaire, puis l’application place le résultat de la SQL_LEN_BINARY_ATTR (*longueur*) macro dans *StringLength*. Cela place une valeur négative dans *StringLength*.  
  
-   Si *ValuePtr* est un pointeur vers une valeur autre qu’une chaîne de caractères ou une chaîne binaire, puis *StringLength* doit avoir la valeur SQL_IS_POINTER.  
  
-   Si *ValuePtr* contient une valeur de longueur fixe, puis *StringLength* est SQL_IS_INTEGER ou SQL_IS_UINTEGER, comme il convient.  
  
## <a name="returns"></a>Valeur renvoyée  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_ERROR ou SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Diagnostics  
 Lorsque **SQLSetStmtAttr** retourne SQL_ERROR ou SQL_SUCCESS_WITH_INFO, une valeur SQLSTATE associée peut être obtenu en appelant **SQLGetDiagRec** avec un *HandleType* de SQL _HANDLE_STMT et un *gérer* de *au paramètre StatementHandle*. Le tableau suivant répertorie les valeurs SQLSTATE généralement retournées par **SQLSetStmtAttr** et explique chacune dans le contexte de cette fonction ; la notation « (DM) » précède les descriptions de SQLSTATE retournée par le Gestionnaire de pilotes. Le code de retour associé à chaque valeur SQLSTATE est SQL_ERROR, sauf indication contraire.  
  
|SQLSTATE|Error|Description|  
|--------------|-----------|-----------------|  
|01000|Avertissement général|Message d’information spécifiques au pilote. (La fonction retourne SQL_SUCCESS_WITH_INFO.)|  
|01S02|Valeur d’option modifiée|Le pilote ne prenait pas en charge la valeur spécifiée dans *ValuePtr*, ou la valeur spécifiée dans *ValuePtr* n’est pas valide en raison de conditions de travail d’implémentation, afin du pilote remplacé une valeur similaire. (**SQLGetStmtAttr** peut être appelée pour déterminer la valeur temporairement substituée.) La valeur de remplacement n’est valide pour le *au paramètre StatementHandle* jusqu'à ce que le curseur est fermé, à quel point l’attribut d’instruction reprend sa valeur précédente. Les attributs d’instruction qui peuvent être modifiés sont :<br /><br /> SQL_ ATTR_CONCURRENCY SQL_ ATTR_CURSOR_TYPE SQL_ ATTR_KEYSET_SIZE SQL_ ATTR_MAX_LENGTH SQL_ ATTR_MAX_ROWS SQL_ ATTR_QUERY_TIMEOUT SQL_ATTR_ROW_ARRAY_SIZE SQL_ ATTR_SIMULATE_CURSOR<br /><br /> (La fonction retourne SQL_SUCCESS_WITH_INFO.)|  
|08S01|Échec de lien de communication|Échec de la liaison de communication entre le pilote et de la source de données à laquelle le pilote a été connecté avant le traitement de la fonction a été exécutée.|  
|24000|État de curseur non valide|Le *attribut* était SQL_ATTR_CURSOR_TYPE, SQL_ATTR_CONCURRENCY, SQL_ATTR_SIMULATE_CURSOR ou SQL_ATTR_USE_BOOKMARKS, et le curseur a été ouvert.|  
|HY000|Erreur générale|Une erreur s’est produite pour laquelle aucun code SQLSTATE spécifique est survenu et pour lequel aucune SQLSTATE spécifiques à l’implémentation a été défini. Le message d’erreur retourné par **SQLGetDiagRec** dans le  *\*MessageText* tampon décrit l’erreur et sa cause.|  
|HY001|Erreur d’allocation de mémoire|Le pilote n’a pas pu allouer la mémoire requise pour prendre en charge l’exécution ou à l’achèvement de la fonction.|  
|HY009|Utilisation non valide de pointeur null|Le *attribut* argument identifié un attribut d’instruction qui a un attribut de chaîne requis et le *ValuePtr* argument était un pointeur null.|  
|HY010|Erreur de séquence de fonction|(DM) une fonction de façon asynchrone en cours d’exécution a été appelée pour le handle de connexion qui est associé à la *au paramètre StatementHandle*. Cette fonction asynchrone était en cours d’exécution lorsque le **SQLSetStmtAttr** fonction a été appelée.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, ou **SQLMoreResults** a été appelé pour le *au paramètre StatementHandle* et retourné SQL_PARAM_DATA_ DISPONIBLE. Cette fonction a été appelée avant que les données ont été récupérées pour tous les paramètres transmis en continu.<br /><br /> (DM) une fonction de façon asynchrone en cours d’exécution a été appelée pour le *au paramètre StatementHandle* et était en cours d’exécution quand cette fonction a été appelée.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**, ou **SQLSetPos** a été appelé pour le  *Au paramètre StatementHandle* et retourné SQL_NEED_DATA. Cette fonction a été appelée avant l’envoi de données pour tous les paramètres de data-at-execution ou les colonnes.|  
|HY011|Attribut ne peut pas être défini maintenant|Le *attribut* était SQL_ATTR_CONCURRENCY, SQL_ ATTR_CURSOR_TYPE, SQL_ ATTR_SIMULATE_CURSOR ou SQL_ ATTR_USE_BOOKMARKS, et l’instruction a été préparée.|  
|HY013|Erreur de gestion de mémoire|L’appel de fonction n’a pas pu être traité, car les objets sous-jacents de la mémoire ne sont pas accessible, probablement en raison de conditions de mémoire insuffisante.|  
|HY017|Utilisation non valide d’un handle de descripteur alloué automatiquement|(DM) le *attribut* argument a été SQL_ATTR_IMP_ROW_DESC ou SQL_ATTR_IMP_PARAM_DESC.<br /><br /> (DM) le *attribut* argument était SQL_ATTR_APP_ROW_DESC ou SQL_ATTR_APP_PARAM_DESC et la valeur dans *ValuePtr* était un handle de descripteur alloué implicitement autre que le handle à l’origine alloué pour le ARD ou APD.|  
|HY024|Valeur d’attribut non valide|Étant donné le spécifié *attribut* , une valeur non valide a été spécifiée dans *ValuePtr*. (Le Gestionnaire de pilotes retourne ce SQLSTATE uniquement pour les connexions et les attributs d’instruction qui acceptent un ensemble discret de valeurs, telles que SQL_ATTR_ACCESS_MODE ou SQL_ ATTR_ASYNC_ENABLE. Pour tous les autres attributs de connexion et instruction, le pilote doit vérifier la valeur spécifiée dans *ValuePtr*.)<br /><br /> Le *attribut* argument a été SQL_ATTR_APP_ROW_DESC ou SQL_ATTR_APP_PARAM_DESC, et *ValuePtr* a été un handle de descripteur alloué explicitement qui n’est pas sur la même connexion que le  *Au paramètre StatementHandle* argument.|  
|HY090|Longueur de chaîne ou une mémoire tampon non valide|(DM)  *\*ValuePtr* est une chaîne de caractères et le *StringLength* argument était inférieure à 0 mais n’était pas SQL_NTS.|  
|HY092|Identificateur d’option/attribut non valide|(DM) la valeur spécifiée pour l’argument *attribut* n’était pas valide pour la version d’ODBC pris en charge par le pilote.<br /><br /> (DM) la valeur spécifiée pour l’argument *attribut* a un attribut en lecture seule.|  
|HY117|Connexion est suspendue en raison de l’état de transaction inconnu. Déconnecter uniquement et les fonctions en lecture seule sont autorisées.|(DM) pour plus d’informations sur l’état suspendu, consultez [SQLEndTran, fonction](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Fonctionnalité optionnelle non implémentée|La valeur spécifiée pour l’argument *attribut* a un attribut d’instruction ODBC valid pour la version d’ODBC pris en charge par le pilote, mais n’était pas pris en charge par le pilote.<br /><br /> Le *attribut* argument était SQL_ATTR_ASYNC_ENABLE et un appel à **SQLGetInfo** avec un *InfoType* de SQL_ASYNC_MODE retourne SQL_AM_CONNECTION.<br /><br /> Le *attribut* argument était SQL_ATTR_ENABLE_AUTO_IPD et la valeur de l’attribut de connexion SQL_ATTR_AUTO_IPD était SQL_FALSE.|  
|HYT01|Délai de connexion expiré|Le délai de connexion a expiré avant que la source de données a répondu à la demande. Le délai de connexion est défini via **SQLSetConnectAttr**, SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Pilote ne prend pas en charge cette fonction|Le pilote (DM) associé le *au paramètre StatementHandle* ne prend pas en charge la fonction.|  
|S1118|Pilote ne prend pas en charge la notification asynchrone|Si l’appel **SQLSetStmtAttr** définir SQL_ATTR_ASYNC_STMT_EVENT ; notification asynchrone n’est pas pris en charge par le pilote.|  
  
## <a name="comments"></a>Commentaires  
 Attributs d’instruction pour une instruction restent en vigueur jusqu'à ce qu’ils sont modifiés par un autre appel à **SQLSetStmtAttr** ou jusqu'à ce que l’instruction est supprimée en appelant **SQLFreeHandle**. Appel **SQLFreeStmt** avec le SQL_CLOSE, SQL_UNBIND ou SQL_RESET_PARAMS option ne réinitialise pas les attributs d’instruction.  
  
 Certains attributs d’instruction de prendre en charge la substitution d’une valeur semblable si la source de données ne prend pas en charge la valeur spécifiée dans *ValuePtr*. Dans ce cas, le pilote retourne SQL_SUCCESS_WITH_INFO et SQLSTATE 01 s 02 (valeur d’Option modifiée). Par exemple, si *attribut* est SQL_ATTR_CONCURRENCY et *ValuePtr* est SQL_CONCUR_ROWVER, et si la source de données ne prend pas en charge cela, le pilote remplace SQL_CONCUR_VALUES retourne SQL_ SUCCESS_WITH_INFO. Pour déterminer la valeur substituée, une application appelle **SQLGetStmtAttr**.  
  
 Le format des informations définies avec *ValuePtr* dépend spécifié *attribut*. **SQLSetStmtAttr** accepte les informations d’attribut dans un des deux formats : une chaîne de caractères ou une valeur entière. Le format de chacun d’eux est indiqué dans la description de l’attribut. Ce format s’applique aux informations retournées pour chaque attribut dans **SQLGetStmtAttr**. Caractères des chaînes vers lequel pointés le *ValuePtr* argument de **SQLSetStmtAttr** avoir une longueur de *StringLength*.  
  
> [!NOTE]  
>  La possibilité de définir des attributs d’instruction au niveau de la connexion en appelant **SQLSetConnectAttr** a été déconseillée dans ODBC 3 *.x*. ODBC 3 *.x* applications ne doivent jamais définir les attributs d’instruction au niveau de la connexion. ODBC 3 *.x* attributs d’instruction ne peut pas être définis au niveau de la connexion, à l’exception des attributs SQL_ATTR_METADATA_ID et SQL_ATTR_ASYNC_ENABLE, qui sont des attributs de connexion et les attributs d’instruction et peut être Définissez au niveau de la connexion ou niveau de l’instruction.  
  
> [!NOTE]  
>  ODBC 3 *.x* pilotes doivent prennent uniquement en charge cette fonctionnalité si elles doivent fonctionner avec ODBC 2 *.x* application qui définira ODBC 2 *.x* options d’instruction au niveau de la connexion. Pour plus d’informations, consultez « Paramètre instruction Options sur le niveau de connexion » sous [SQLSetConnectOption mappage](../../../odbc/reference/appendixes/sqlsetconnectoption-mapping.md) dans la section annexe g : pilote instructions pour la compatibilité descendante.  
  
## <a name="statement-attributes-that-set-descriptor-fields"></a>Attributs d’instruction que définir des champs de descripteur  
 Plusieurs attributs d’instruction correspondent à un champ d’en-tête d’un descripteur. Définition de ces attributs en fait les résultats dans le paramètre des champs de descripteur. Définition des champs par un appel à **SQLSetStmtAttr** plutôt que **SQLSetDescField** présente l’avantage qu’un handle de descripteur n’est pas à obtenir pour l’appel de fonction.  
  
> [!CAUTION]  
>  Appel **SQLSetStmtAttr** pour une seule instruction peut affecter les autres instructions. Ceci se produit lorsque le APD ou ARD associé à l’instruction est explicitement alloué est également associé avec d’autres instructions. Étant donné que **SQLSetStmtAttr** modifie le APD ou ARD, les modifications s’appliquent à toutes les instructions à laquelle ce descripteur est associé. Si ce comportement n’est pas obligatoire, l’application doit dissocier ce descripteur à partir d’autres instructions (en appelant **SQLSetStmtAttr** pour définir le champ SQL_ATTR_APP_ROW_DESC ou SQL_ATTR_APP_PARAM_DESC vers un autre handle du descripteur) avant d’appeler **SQLSetStmtAttr** à nouveau.  
  
 Lorsqu’un champ de descripteur est défini à la suite de l’attribut d’instruction correspondant qui est définie, le champ est défini uniquement pour les descripteurs applicables qui sont actuellement associés à l’instruction identifiée par le *au paramètre StatementHandle* argument et le paramètre d’attribut n’affecte pas tous les descripteurs qui peuvent être associés à cette instruction à l’avenir. Quand un champ de descripteur qui est également un attribut d’instruction est défini par un appel à **SQLSetDescField**, l’attribut d’instruction correspondant est défini. Si un descripteur explicitement alloué est dissocié d’une instruction, un attribut d’instruction qui correspond à un champ d’en-tête reviendra à la valeur du champ dans le descripteur alloué implicitement.  
  
 Lorsqu’une instruction est allouée (consultez [SQLAllocHandle](../../../odbc/reference/syntax/sqlallochandle-function.md)), les handles de descripteur quatre sont automatiquement alloués et associés à l’instruction. Handles de descripteur alloué de manière explicite peuvent être associés à l’instruction en appelant **SQLAllocHandle** avec un *fHandleType* de SQL_HANDLE_DESC pour allouer un handle de descripteur et à appeler ensuite  **SQLSetStmtAttr** à associer le handle du descripteur de l’instruction.  
  
 Les attributs d’instruction dans le tableau suivant correspondent aux champs d’en-tête de descripteur.  
  
|attribut d’instruction|Champ d’en-tête|DESC.|  
|-------------------------|------------------|-----------|  
|SQL_ATTR_PARAM_BIND_OFFSET_PTR|SQL_DESC_BIND_OFFSET_PTR|APD|  
|SQL_ATTR_PARAM_BIND_TYPE|SQL_DESC_BIND_TYPE|APD|  
|SQL_ATTR_PARAM_OPERATION_PTR|SQL_DESC_ARRAY_STATUS_PTR|APD|  
|SQL_ATTR_PARAM_STATUS_PTR|SQL_DESC_ARRAY_STATUS_PTR|IPD|  
|SQL_ATTR_PARAMS_PROCESSED_PTR|SQL_DESC_ROWS_PROCESSED_PTR|IPD|  
|SQL_ATTR_PARAMSET_SIZE|SQL_DESC_ARRAY_SIZE|APD|  
|SQL_ATTR_ROW_ARRAY_SIZE|SQL_DESC_ARRAY_SIZE|ARD|  
|SQL_ATTR_ROW_BIND_OFFSET_PTR|SQL_DESC_BIND_OFFSET_PTR|ARD|  
|SQL_ATTR_ROW_BIND_TYPE|SQL_DESC_BIND_TYPE|ARD|  
|SQL_ATTR_ROW_OPERATION_PTR|SQL_DESC_ARRAY_STATUS_PTR|ARD|  
|SQL_ATTR_ROW_STATUS_PTR|SQL_DESC_ARRAY_STATUS_PTR|IRD|  
|SQL_ATTR_ROWS_FETCHED_PTR|SQL_DESC_ROWS_PROCESSED_PTR|IRD|  
  
## <a name="statement-attributes"></a>Attributs d'instruction  
 Les attributs actuellement définis et la version d’ODBC dans lequel ils ont été introduites sont affichés dans le tableau suivant ; Il est probable que plus d’attributs seront définis par les pilotes pour tirer parti de différentes sources de données. Une plage d’attributs est réservée par ODBC ; les développeurs de pilotes doivent réserver des valeurs pour leur propre usage spécifiques au pilote à partir d’Open Group. Pour plus d’informations, consultez [les Types de données spécifiques au pilote, Types de descripteurs, Types d’informations, Types de diagnostics et attributs](../../../odbc/reference/develop-app/driver-specific-data-types-descriptor-information-diagnostic.md).  
  
|Attribute|*ValuePtr* contenu|  
|---------------|-------------------------|  
|SQL_ATTR_APP_PARAM_DESC (ODBC 3.0)|Le handle pour le descripteur APD pour les appels suivants à **SQLExecute** et **SQLExecDirect** sur le descripteur d’instruction. La valeur initiale de cet attribut est le descripteur alloué implicitement lorsque l’instruction a été initialement allouée. Si la valeur de cet attribut est définie à SQL_NULL_DESC ou le handle alloué à l’origine pour le descripteur, alloués explicitement APD handle qui a été précédemment associé au descripteur d’instruction est dissocié à partir de celui-ci et le descripteur d’instruction revient à la alloués implicitement les descripteur APD.<br /><br /> Cet attribut ne peut pas être défini à un handle de descripteur qui a été implicitement alloué pour une autre instruction ou vers un autre handle de descripteur qui a été implicitement défini sur la même instruction ; handles de descripteur alloué implicitement ne peut pas être associés à plusieurs instructions ou le handle du descripteur.|  
|SQL_ATTR_APP_ROW_DESC (ODBC 3.0)|Le handle vers la ARD pour les extractions suivantes sur le descripteur d’instruction. La valeur initiale de cet attribut est le descripteur alloué implicitement lorsque l’instruction a été initialement allouée. Si la valeur de cet attribut est définie à SQL_NULL_DESC ou le handle alloué à l’origine pour le descripteur, alloués explicitement ARD handle qui a été précédemment associé au descripteur d’instruction est dissocié à partir de celui-ci et le descripteur d’instruction revient à la alloués implicitement handle ARD.<br /><br /> Cet attribut ne peut pas être défini à un handle de descripteur qui a été implicitement alloué pour une autre instruction ou vers un autre handle de descripteur qui a été implicitement défini sur la même instruction ; handles de descripteur alloué implicitement ne peut pas être associés à plusieurs instructions ou le handle du descripteur.|  
|SQL_ATTR_ASYNC_ENABLE (ODBC 1.0)|Une valeur SQLULEN qui spécifie si une fonction appelée avec l’instruction spécifiée est exécutée de façon asynchrone :<br /><br /> SQL_ASYNC_ENABLE_OFF = prise en charge au niveau de l’exécution asynchrone sous forme d’instruction Disable (la valeur par défaut).<br /><br /> SQL_ASYNC_ENABLE_ON = prise en charge de Enable instruction au niveau de l’exécution asynchrone.<br /><br /> Pour plus d’informations, consultez [exécution asynchrone (méthode d’interrogation)](../../../odbc/reference/develop-app/asynchronous-execution-polling-method.md).<br /><br /> Pour les pilotes avec prise en charge de l’exécution asynchrone au niveau instruction, l’attribut d’instruction SQL_ATTR_ASYNC_ENABLE est en lecture seule. Sa valeur est identique à la valeur de l’attribut de niveau connexion portant le même nom au moment où que le handle d’instruction a été alloué.<br /><br /> Appel **SQLSetStmtAttr** pour définir SQL_ATTR_ASYNC_ENABLE lorsque le SQL_ASYNC_MODE *InfoType* retourne SQL_AM_CONNECTION retourne SQLSTATE HYC00 (fonctionnalité facultative non implémentée). Pour plus d’informations, consultez [fonction SQLSetConnectAttr](../../../odbc/reference/syntax/sqlsetconnectattr-function.md) pour plus d’informations.|  
|SQL_ATTR_ASYNC_STMT_EVENT (ODBC 3.8)|Une valeur SQLPOINTER qui est un handle d’événement.<br /><br /> Notification de fin des fonctions asynchrones est activée en appelant **SQLSetStmtAttr** pour définir le **SQL_ATTR_ASYNC_STMT_EVENT** d’attribut et spécifiez le handle d’événement.|  
|SQL_ATTR_ASYNC_STMT_PCALLBACK (ODBC 3.8)|Un SQLPOINTER vers la fonction de rappel asynchrone.<br /><br /> Seul le Gestionnaire de pilotes peut appeler un chauffeur **SQLSetStmtAttr** fonction avec cet attribut.|  
|SQL_ATTR_ASYNC_STMT_PCONTEXT (ODBC 3.8)|Un SQLPOINTER vers la structure de contexte<br /><br /> Seul le Gestionnaire de pilotes peut appeler un chauffeur **SQLSetStmtAttr** fonction avec cet attribut.|  
|SQL_ATTR_CONCURRENCY (ODBC 2.0)|Une valeur SQLULEN qui spécifie l’accès concurrentiel au curseur :<br /><br /> SQL_CONCUR_READ_ONLY = curseur est en lecture seule. Aucune mise à jour n’est autorisées.<br /><br /> SQL_CONCUR_LOCK = curseur utilise le niveau de verrouillage pour vous assurer que la ligne peut être mis à jour le plus bas.<br /><br /> SQL_CONCUR_ROWVER = le contrôle d’accès concurrentiel optimiste curseur utilise en comparant des versions de ligne telles que SQLBase ROWID ou Sybase TIMESTAMP.<br /><br /> SQL_CONCUR_VALUES = le contrôle d’accès concurrentiel optimiste curseur utilise en comparant les valeurs.<br /><br /> La valeur par défaut pour SQL_ATTR_CONCURRENCY est SQL_CONCUR_READ_ONLY.<br /><br /> Cet attribut ne peut pas être spécifié pour un curseur ouvert. Pour plus d’informations, consultez [les Types d’accès concurrentiel](../../../odbc/reference/develop-app/concurrency-types.md).<br /><br /> Si le SQL_ATTR_CURSOR_TYPE *attribut* est modifié en un type qui ne prend pas en charge la valeur actuelle de SQL_ATTR_CONCURRENCY, la valeur de SQL_ATTR_CONCURRENCY passera au moment de l’exécution et un avertissement s’affiche lorsque **SQLExecDirect** ou **SQLPrepare** est appelée.<br /><br /> Si le pilote prend en charge la **SELECT FOR UPDATE** instruction et une telle instruction est exécutée alors que la valeur de SQL_ATTR_CONCURRENCY est définie sur la valeur SQL_CONCUR_READ_ONLY, une erreur s’affichera. Si la valeur de SQL_ATTR_CONCURRENCY est modifiée sur une valeur que le pilote prend en charge pour une valeur de SQL_ATTR_CURSOR_TYPE mais pas pour la valeur actuelle de SQL_ATTR_CURSOR_TYPE, la valeur de SQL_ATTR_CURSOR_TYPE passera au moment de l’exécution et de SQLSTATE 01 s 02 (Valeur d’option modifiée) est émis lorsque **SQLExecDirect** ou **SQLPrepare** est appelée.<br /><br /> Si l’accès concurrentiel spécifié n’est pas pris en charge par la source de données, le pilote remplace une simultanéité différent et retourne SQLSTATE 01 s 02 (valeur d’Option modifiée). Pour SQL_CONCUR_VALUES, le pilote remplace SQL_CONCUR_ROWVER et vice versa. Pour SQL_CONCUR_LOCK, le pilote remplace, dans l’ordre, SQL_CONCUR_ROWVER ou SQL_CONCUR_VALUES. La validité de la valeur de substitution n’est pas vérifiée jusqu’au moment de l’exécution.<br /><br /> Pour plus d’informations sur la relation entre SQL_ATTR_CONCURRENCY et les autres attributs de curseur, consultez [caractéristiques du curseur et le Type de curseur](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_CURSOR_SCROLLABLE (ODBC 3.0)|Une valeur SQLULEN qui spécifie le niveau de prise en charge requis par l’application. Si cet attribut a une incidence sur les appels suivants à **SQLExecDirect** et **SQLExecute**.<br /><br /> SQL_NONSCROLLABLE = à défilement les curseurs ne sont pas requis sur le descripteur d’instruction. Si l’application appelle **SQLFetchScroll** sur ce handle, la seule valeur valide de *FetchOrientation* est SQL_FETCH_NEXT. Il s'agit du paramètre par défaut.<br /><br /> SQL_SCROLLABLE = à défilement les curseurs sont requises sur le descripteur d’instruction. Lors de l’appel **SQLFetchScroll**, l’application peut spécifier les valeurs valides de *FetchOrientation*, atteindre le positionnement du curseur dans les modes autres que le mode séquentiel.<br /><br /> Pour plus d’informations sur les curseurs avec défilement, consultez [curseurs avec défilement](../../../odbc/reference/develop-app/scrollable-cursors.md). Pour plus d’informations sur la relation entre SQL_ATTR_CURSOR_SCROLLABLE et les autres attributs de curseur, consultez [caractéristiques du curseur et le Type de curseur](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md)|  
|SQL_ATTR_CURSOR_SENSITIVITY (ODBC 3.0)|Un SQLULEN qui spécifie si les curseurs sur le descripteur d’instruction rendre visibles les modifications apportées à un résultat de la valeur par un autre curseur. Si cet attribut a une incidence sur les appels suivants à **SQLExecDirect** et **SQLExecute**. Une application peut lire la valeur de cet attribut pour obtenir son état ou son état initial comme étant plus récemment définie par l’application.<br /><br /> SQL_UNSPECIFIED = il n’est pas spécifié le type de curseur et indique si les curseurs sur le descripteur d’instruction rendre visibles les modifications apportées à un jeu de résultats par un autre curseur. Les curseurs sur le descripteur d’instruction peuvent rendre visible à none, tout ou partie de ces modifications. Il s'agit du paramètre par défaut.<br /><br /> SQL_INSENSITIVE = tous les curseurs sur instruction handle afficher le jeu de résultats sans montrer toutes les modifications apportées à ce dernier par n’importe quel autre curseur. Curseurs INSENSITIVE sont en lecture seule. Cela correspond à un curseur statique, ce qui a une concurrence est en lecture seule.<br /><br /> SQL_SENSITIVE = tous les curseurs d’instruction handle rendre visible toutes les modifications apportées à un résultat définies par un autre curseur.<br /><br /> Pour plus d’informations sur la relation entre SQL_ATTR_CURSOR_SENSITIVITY et les autres attributs de curseur, consultez [caractéristiques du curseur et le Type de curseur](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_CURSOR_TYPE (ODBC 2.0)|Une valeur SQLULEN qui spécifie le type de curseur :<br /><br /> SQL_CURSOR_FORWARD_ONLY = le curseur uniquement fait défiler vers l’avant.<br /><br /> SQL_CURSOR_STATIC = les données dans le résultat de l’ensemble est statique.<br /><br /> SQL_CURSOR_KEYSET_DRIVEN = le pilote enregistre et utilise les clés pour le nombre de lignes spécifié dans l’attribut d’instruction SQL_ATTR_KEYSET_SIZE.<br /><br /> Type SQL_CURSOR_DYNAMIC = le pilote enregistre et utilise uniquement les clés pour les lignes dans l’ensemble de lignes.<br /><br /> La valeur par défaut est SQL_CURSOR_FORWARD_ONLY. Cet attribut ne peut pas être spécifié après que l’instruction SQL a été préparée.<br /><br /> Si le type de curseur spécifié n’est pas pris en charge par la source de données, le pilote remplace un autre type de curseur et retourne SQLSTATE 01 s 02 (valeur d’Option modifiée). Pour un curseur dynamique ou mixte, le pilote remplace, dans l’ordre, un par keyset ou en curseur statique. Pour un curseur keyset, le pilote remplace un curseur statique.<br /><br /> Pour plus d’informations sur les types de curseur de défilement, consultez [des Types de curseurs avec défilement](../../../odbc/reference/develop-app/scrollable-cursor-types.md). Pour plus d’informations sur la relation entre SQL_ATTR_CURSOR_TYPE et les autres attributs de curseur, consultez [caractéristiques du curseur et le Type de curseur](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_ENABLE_AUTO_IPD (ODBC 3.0)|Une valeur SQLULEN qui spécifie si le remplissage automatique de l’IPD est effectuée :<br /><br /> SQL_TRUE = Active remplissage automatique de l’IPD après un appel à **SQLPrepare**. SQL_FALSE = désactive remplissage automatique de l’IPD après un appel à **SQLPrepare**. (Une application peut toujours obtenir les informations de champ IPD en appelant **SQLDescribeParam**, si pris en charge.) La valeur par défaut de l’attribut d’instruction SQL_ATTR_ENABLE_AUTO_IPD est SQL_FALSE. Pour plus d’informations, consultez [remplissage automatique de l’IPD](../../../odbc/reference/develop-app/automatic-population-of-the-ipd.md).|  
|SQL_ATTR_FETCH_BOOKMARK_PTR (ODBC 3.0)|Un SQLLEN \* qui pointe vers une valeur binaire de signet. Lorsque **SQLFetchScroll** est appelée avec *fFetchOrientation* égal à SQL_FETCH_BOOKMARK, le pilote récupère la valeur du signet à partir de ce champ. Par défaut, ce champ est un pointeur null. Pour plus d’informations, consultez [le défilement par signet](../../../odbc/reference/develop-app/scrolling-by-bookmark.md).<br /><br /> La valeur indiquée par ce champ n’est pas utilisée pour la suppression par signet, mettre à jour par un signet ou extraire par les opérations de signet dans **SQLBulkOperations**, qui utilisent des signets mis en cache des tampons de l’ensemble de lignes.|  
|SQL_ATTR_IMP_PARAM_DESC (ODBC 3.0)|Le handle vers l’IPD. La valeur de cet attribut est le descripteur alloué lors de l’instruction a été initialement allouée. L’application ne peut pas définir cet attribut.<br /><br /> Cet attribut peut être récupéré par un appel à **SQLGetStmtAttr** mais pas défini par un appel à **SQLSetStmtAttr**.|  
|SQL_ATTR_IMP_ROW_DESC (ODBC 3.0)|Le handle vers le descripteur IRD. La valeur de cet attribut est le descripteur alloué lors de l’instruction a été initialement allouée. L’application ne peut pas définir cet attribut.<br /><br /> Cet attribut peut être récupéré par un appel à **SQLGetStmtAttr** mais pas défini par un appel à **SQLSetStmtAttr**.|  
|SQL_ATTR_KEYSET_SIZE (ODBC 2.0)|SQLULEN qui spécifie le nombre de lignes dans le jeu de clés pour un curseur keyset. Si la taille de jeu de clés est 0 (valeur par défaut), le curseur se trouve entièrement commandé par keyset. Si la taille de jeu de clés est supérieure à 0, le curseur est mixte (keyset dans le jeu de clés et dynamiques en dehors du jeu de clés). La taille du jeu de clés par défaut est 0. Pour plus d’informations sur les curseurs, consultez [curseurs contrôlés par clés](../../../odbc/reference/develop-app/keyset-driven-cursors.md).<br /><br /> Si la taille spécifiée dépasse la taille maximale de jeu de clés, le pilote remplace cette taille et retourne SQLSTATE 01 s 02 (valeur d’Option modifiée).<br /><br /> **SQLFetch** ou **SQLFetchScroll** retourne une erreur si la taille de jeu de clés est supérieur à 0 et inférieur à la taille de l’ensemble de lignes.|  
|SQL_ATTR_MAX_LENGTH (ODBC 1.0)|Une valeur SQLULEN qui spécifie la quantité maximale de données que le pilote retourne à partir d’une colonne caractère ou binaire. Si *ValuePtr* est inférieure à la longueur des données disponibles, **SQLFetch** ou **SQLGetData** tronque les données et retourne SQL_SUCCESS. Si *ValuePtr* est 0 (valeur par défaut), le pilote tente de retourner toutes les données disponibles.<br /><br /> Si la longueur spécifiée est inférieure à la quantité minimale de données que la source de données peut renvoyer ou supérieur à la quantité maximale de données que la source de données peut renvoyer, substituts de pilote qui valeur et retourne SQLSTATE 01 s 02 (valeur d’Option modifiée).<br /><br /> La valeur de cet attribut peut être définie sur un curseur ouvert ; Toutefois, le paramètre ne peut-être pas immédiatement en vigueur, dans ce cas, le pilote retournera SQLSTATE 01 s 02 (valeur d’Option modifiée) et réinitialiser l’attribut à sa valeur d’origine.<br /><br /> Cet attribut est destiné à réduire le trafic réseau et doit être pris en charge uniquement lorsque la source de données (par opposition au pilote) dans un pilote à plusieurs niveaux permettre l’implémenter. Ce mécanisme ne doit pas être utilisé par les applications tronquer des données ; pour tronquer les données reçues, une application doit spécifier la longueur maximale de mémoire tampon dans le *BufferLength* argument dans **SQLBindCol** ou **SQLGetData**.|  
|SQL_ATTR_MAX_ROWS (ODBC 1.0)|Une valeur SQLULEN correspondant au nombre maximal de lignes à retourner à l’application pour un **sélectionnez** instruction. Si \* *ValuePtr* est égal à 0 (valeur par défaut), le pilote retourne toutes les lignes.<br /><br /> Cet attribut est destiné à réduire le trafic réseau. Sur le plan conceptuel, elle est appliquée lorsque le jeu de résultats est créé et limite le jeu de résultats à la première *ValuePtr* lignes. Si le nombre de lignes du jeu de résultats est supérieur à *ValuePtr*, le jeu de résultats est tronqué.<br /><br /> SQL_ATTR_MAX_ROWS s’applique à tous les jeux de résultats pour le *instruction*, y compris ceux retournés par les fonctions de catalogue. SQL_ATTR_MAX_ROWS établit un maximum pour la valeur du nombre de lignes de curseur.<br /><br /> Un pilote n’a pas doit émuler le comportement SQL_ATTR_MAX_ROWS pour **SQLFetch** ou **SQLFetchScroll** (si les limitations de taille de jeu de résultats ne peut pas être implémentées à la source de données) si elle ne peut pas garantir que SQL_ATTR_ MAX_ROWS seront implémentés correctement.<br /><br /> Elle est définie par le pilote si SQL_ATTR_MAX_ROWS s’applique aux instructions autres que des instructions SELECT (par exemple, les fonctions de catalogue).<br /><br /> La valeur de cet attribut peut être définie sur un curseur ouvert ; Toutefois, le paramètre ne peut-être pas immédiatement en vigueur, dans ce cas, le pilote retournera SQLSTATE 01 s 02 (valeur d’Option modifiée) et réinitialiser l’attribut à sa valeur d’origine.|  
|SQL_ATTR_METADATA_ID (ODBC 3.0)|Une valeur SQLULEN qui détermine la façon dont les arguments de chaîne de fonctions de catalogue sont traités.<br /><br /> Si SQL_TRUE, l’argument de chaîne de fonctions de catalogue sont traitées comme identificateurs. Le cas n’est pas significatif. Pour les chaînes non délimités, le pilote supprime les espaces de fin et la chaîne est assemblée en majuscules. Pour des chaînes délimitées, le pilote supprime les espaces de début ou de fin et prend tout ce qui est situé entre les délimiteurs littéralement. Si un de ces arguments est défini sur un pointeur null, la fonction retourne SQL_ERROR et SQLSTATE HY009 (utilisation non valide d’un pointeur null).<br /><br /> Si SQL_FALSE, les arguments de chaîne de fonctions de catalogue ne sont pas traitées comme identificateurs. Le cas est significatif. Ils peuvent contenir un modèle de recherche de chaîne ou pas, en fonction de l’argument.<br /><br /> La valeur par défaut est SQL_FALSE.<br /><br /> Le *TableType* argument de **SQLTables**, qui accepte une liste de valeurs, n’est pas affecté par cet attribut.<br /><br /> SQL_ATTR_METADATA_ID peut également être définie sur le niveau de la connexion. (Il et SQL_ATTR_ASYNC_ENABLE sont les attributs de la seule instruction qui sont également des attributs de connexion).<br /><br /> Pour plus d’informations, consultez [Arguments dans les fonctions de catalogue](../../../odbc/reference/develop-app/arguments-in-catalog-functions.md).|  
|SQL_ATTR_NOSCAN (ODBC 1.0)|Une valeur SQLULEN qui indique si le pilote doit analyser des chaînes SQL pour les séquences d’échappement :<br /><br /> SQL_NOSCAN_OFF = les analyses de pilote chaînes SQL pour les séquences d’échappement (par défaut).<br /><br /> SQL_NOSCAN_ON = le pilote n’analyse pas les chaînes SQL pour les séquences d’échappement. Au lieu de cela, le pilote envoie l’instruction directement à la source de données.<br /><br /> Pour plus d’informations, consultez [les séquences d’échappement dans ODBC](../../../odbc/reference/develop-app/escape-sequences-in-odbc.md).|  
|SQL_ATTR_PARAM_BIND_OFFSET_PTR (ODBC 3.0)|Un SQLULEN * valeur pointe vers un offset ajouté aux pointeurs de modifier la liaison de paramètres dynamiques. Si ce champ est non null, le pilote déréférence le pointeur, ajoute la valeur déréférencée à chacun des champs différés dans l’enregistrement de descripteur (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR et SQL_DESC_OCTET_LENGTH_PTR) et utilise les nouvelles valeurs de pointeur lors de la liaison. Il a la valeur NULL par défaut.<br /><br /> Le décalage de la liaison est toujours ajouté directement aux champs SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR et SQL_DESC_OCTET_LENGTH_PTR. Si le décalage est modifié sur une autre valeur, la nouvelle valeur est toujours ajoutée directement à la valeur dans le champ de descripteur. Le nouveau décalage n’est pas ajouté à la valeur du champ ainsi que les décalages antérieures.<br /><br /> Pour plus d’informations, consultez [Offsets de liaison de paramètre](../../../odbc/reference/develop-app/parameter-binding-offsets.md).<br /><br /> Si cet attribut d’instruction définit le champ SQL_DESC_BIND_OFFSET_PTR dans l’en-tête APD.|  
|SQL_ATTR_PARAM_BIND_TYPE (ODBC 3.0)|Une valeur SQLULEN qui indique l’orientation de la liaison à utiliser pour les paramètres dynamiques.<br /><br /> Ce champ est défini sur SQL_PARAM_BIND_BY_COLUMN (la valeur par défaut) pour sélectionner la liaison.<br /><br /> Pour sélectionner la liaison, ce champ est défini sur la longueur de la structure ou une instance d’une mémoire tampon qui sera liée à un ensemble de paramètres dynamiques. Cette durée doit inclure l’espace pour tous les paramètres liés et tout remplissage de la structure ou de la mémoire tampon pour vous assurer que lorsque l’adresse d’un paramètre dépendant est incrémenté avec la longueur spécifiée, le résultat pointera vers le début du même paramètre dans la prochaine ensemble de paramètres. Lorsque vous utilisez le *sizeof* opérateur en C ANSI, ce comportement est garanti.<br /><br /> Pour plus d’informations, consultez [liaison de tableaux de paramètres](../../../odbc/reference/develop-app/binding-arrays-of-parameters.md).<br /><br /> Si cet attribut d’instruction définit le champ SQL_DESC_ BIND_TYPE dans l’en-tête APD.|  
|SQL_ATTR_PARAM_OPERATION_PTR (ODBC 3.0)|Un SQLUSMALLINT \* valeur pointe vers un tableau de valeurs SQLUSMALLINT utilisé pour ignorer un paramètre pendant l’exécution d’une instruction SQL. Chaque valeur est définie sur SQL_PARAM_PROCEED (pour le paramètre doit être exécuté) ou SQL_PARAM_IGNORE (pour le paramètre est ignoré).<br /><br /> Un ensemble de paramètres peut être ignoré pendant le traitement en définissant la valeur d’état dans le tableau pointé par SQL_DESC_ARRAY_STATUS_PTR dans le descripteur APD à SQL_PARAM_IGNORE. Un ensemble de paramètres est traité si son état a la valeur SQL_PARAM_PROCEED ou si aucun élément du tableau n’est défini.<br /><br /> Cet attribut d’instruction peut être défini à un pointeur null, dans lequel le cas, le pilote ne retourne pas paramètre valeurs d’état. Cet attribut peut être défini à tout moment, mais la nouvelle valeur n’est pas utilisée jusqu'à la prochaine **SQLExecDirect** ou **SQLExecute** est appelée.<br /><br /> Cet attribut est ignoré lorsqu’il n’existe aucun paramètre lié.<br /><br /> Pour plus d’informations, consultez [à l’aide des tableaux de paramètres](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> Si cet attribut d’instruction définit le champ SQL_DESC_ARRAY_STATUS_PTR dans l’en-tête APD.|  
|SQL_ATTR_PARAM_STATUS_PTR (ODBC 3.0)|Un SQLUSMALLINT \* valeur qui pointe vers un tableau de SQLUSMALLINT valeurs contenant des informations de statut pour chaque ligne de valeurs de paramètre après un appel à **SQLExecute** ou **SQLExecDirect**. Ce champ est obligatoire uniquement si PARAMSET_SIZE est supérieur à 1.<br /><br /> Les valeurs d’état peuvent contenir les valeurs suivantes :<br /><br /> SQL_PARAM_SUCCESS : L’instruction SQL a été exécutée avec succès pour ce jeu de paramètres.<br /><br /> SQL_PARAM_SUCCESS_WITH_INFO : L’instruction SQL a été exécutée avec succès pour ce jeu de paramètres ; Toutefois, les informations d’avertissement sont disponibles dans la structure de données de diagnostic.<br /><br /> SQL_PARAM_ERROR : Il une erreur s’est produite lors du traitement de cet ensemble de paramètres. Informations d’erreur supplémentaires sont disponibles dans la structure de données de diagnostic.<br /><br /> SQL_PARAM_UNUSED : Ce jeu de paramètres a été inutilisé, probablement dû au fait que certains précédent jeu de paramètres a provoqué une erreur qui a abandonné le traitement supplémentaire, ou parce que SQL_PARAM_IGNORE a été défini pour ce jeu de paramètres dans le tableau spécifié par le SQL_ATTR_PARAM_ OPERATION_PTR.<br /><br /> SQL_PARAM_DIAG_UNAVAILABLE : Le pilote traite les tableaux de paramètres comme une unité monolithique et par conséquent, ne génère pas de ce niveau d’informations sur l’erreur.<br /><br /> Cet attribut d’instruction peut être défini à un pointeur null, dans lequel le cas, le pilote ne retourne pas paramètre valeurs d’état. Cet attribut peut être défini à tout moment, mais la nouvelle valeur n’est pas utilisée jusqu'à la prochaine **SQLExecute** ou **SQLExecDirect** est appelée. Notez que la définition de cet attribut peut affecter le comportement du paramètre de sortie implémenté par le pilote.<br /><br /> Pour plus d’informations, consultez [à l’aide des tableaux de paramètres](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> Si cet attribut d’instruction définit le champ SQL_DESC_ARRAY_STATUS_PTR dans l’en-tête IPD.|  
|SQL_ATTR_PARAMS_PROCESSED_PTR (ODBC 3.0)|Un SQLULEN \* champs d’enregistrements qui pointe vers une mémoire tampon dans lequel retourner le nombre de jeux de paramètres qui ont été traités, y compris des ensembles de l’erreur. Aucun nombre n’est retourné s’il s’agit d’un pointeur null.<br /><br /> Si cet attribut d’instruction définit le champ SQL_DESC_ROWS_PROCESSED_PTR dans l’en-tête IPD.<br /><br /> Si l’appel à **SQLExecDirect** ou **SQLExecute** que remplit la mémoire tampon désignée par cet attribut ne retourne pas SQL_SUCCESS ou SQL_SUCCESS_WITH_INFO, le contenu de la mémoire tampon n’est pas défini.<br /><br /> Pour plus d’informations, consultez [à l’aide des tableaux de paramètres](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).|  
|SQL_ATTR_PARAMSET_SIZE (ODBC 3.0)|Une valeur SQLULEN qui spécifie le nombre de valeurs pour chaque paramètre. Si SQL_ATTR_PARAMSET_SIZE est supérieure à 1, SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR et SQL_DESC_OCTET_LENGTH_PTR du point APD aux tableaux. La cardinalité de chaque tableau est égale à la valeur de ce champ.<br /><br /> Cet attribut est ignoré lorsqu’il n’existe aucun paramètre lié.<br /><br /> Pour plus d’informations, consultez [à l’aide des tableaux de paramètres](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> Si cet attribut d’instruction définit le champ SQL_DESC_ARRAY_SIZE dans l’en-tête APD.|  
|SQL_ATTR_QUERY_TIMEOUT (ODBC 1.0)|Une valeur SQLULEN correspondant au nombre de secondes d’attente d’une instruction SQL à exécuter avant de retourner à l’application. Si *ValuePtr* est égal à 0 (valeur par défaut), il n’existe aucun délai d’expiration.<br /><br /> Si le délai spécifié dépasse le délai d’attente maximal dans la source de données ou est plus petit que le délai d’attente minimal, **SQLSetStmtAttr** substitue cette valeur et retourne SQLSTATE 01 s 02 (valeur d’Option modifiée).<br /><br /> Notez que l’application ne doive pas appeler **SQLCloseCursor** à réutiliser l’instruction si un **sélectionnez** instruction a expiré.<br /><br /> Le délai d’expiration de requête de cet attribut d’instruction est valide dans les modes synchrones et asynchrones.|  
|SQL_ATTR_RETRIEVE_DATA (ODBC 2.0)|Une valeur SQLULEN :<br /><br /> SQL_RD_ON = **SQLFetchScroll** et, dans ODBC 3 *.x*, **SQLFetch** récupérer des données après qu’il place le curseur à l’emplacement spécifié. Il s'agit du paramètre par défaut.<br /><br /> SQL_RD_OFF = **SQLFetchScroll** et, dans ODBC 3 *.x*, **SQLFetch** ne récupèrent pas les données une fois qu’il place le curseur.<br /><br /> En définissant SQL_RETRIEVE_DATA sur SQL_RD_OFF, une application peut vérifier qu’une ligne existe ou récupérer un signet pour la ligne sans subir la surcharge de l’extraction de lignes. Pour plus d’informations, consultez [défilement et extraction des lignes](../../../odbc/reference/develop-app/scrolling-and-fetching-rows-odbc.md).<br /><br /> La valeur de cet attribut peut être définie sur un curseur ouvert ; Toutefois, le paramètre ne peut-être pas immédiatement en vigueur, dans ce cas, le pilote retournera SQLSTATE 01 s 02 (valeur d’Option modifiée) et réinitialiser l’attribut à sa valeur d’origine.|  
|SQL_ATTR_ROW_ARRAY_SIZE (ODBC 3.0)|Une valeur SQLULEN qui spécifie le nombre de lignes retournées par chaque appel à **SQLFetch** ou **SQLFetchScroll**. Il est également le nombre de lignes dans un tableau de signet utilisée dans une opération de signet en bloc dans **SQLBulkOperations**. La valeur par défaut est 1.<br /><br /> Si la taille de l’ensemble de lignes spécifié dépasse la taille maximale prise en charge par la source de données, le pilote remplace cette valeur et retourne SQLSTATE 01 s 02 (valeur d’Option modifiée).<br /><br /> Pour plus d’informations, consultez [taille de l’ensemble de lignes](../../../odbc/reference/develop-app/rowset-size.md).<br /><br /> Si cet attribut d’instruction définit le champ SQL_DESC_ARRAY_SIZE dans l’en-tête ARD.|  
|SQL_ATTR_ROW_BIND_OFFSET_PTR (ODBC 3.0)|Un SQLULEN * valeur pointe vers un offset ajouté aux pointeurs de modifier la liaison de données de la colonne. Si ce champ est non null, le pilote déréférence le pointeur, ajoute la valeur déréférencée à chacun des champs différés dans l’enregistrement de descripteur (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR et SQL_DESC_OCTET_LENGTH_PTR) et utilise les nouvelles valeurs de pointeur lors de la liaison. Il a la valeur NULL par défaut.<br /><br /> Si cet attribut d’instruction définit le champ SQL_DESC_BIND_OFFSET_PTR dans l’en-tête ARD.|  
|SQL_ATTR_ROW_BIND_TYPE (ODBC 1.0)|Une valeur SQLULEN qui définit l’orientation de la liaison à utiliser lorsque **SQLFetch** ou **SQLFetchScroll** est appelée sur l’instruction associée. La liaison est sélectionnée en définissant la valeur sur SQL_BIND_BY_COLUMN. La liaison est sélectionnée en définissant la valeur à la longueur d’une structure ou une instance d’une mémoire tampon dans laquelle les colonnes de résultats seront liés.<br /><br /> Si une longueur est spécifiée, elle doit inclure l’espace pour toutes les colonnes dépendantes et tout remplissage de la structure ou de la mémoire tampon pour vous assurer que lorsque l’adresse d’une colonne dépendante est incrémentée avec la longueur spécifiée, le résultat pointera vers le début de la même colonne dans th ligne suivante de e. Lorsque vous utilisez le **sizeof** opérateur avec structures ou unions en C ANSI, ce comportement est garanti.<br /><br /> La liaison est l’orientation de la liaison par défaut pour **SQLFetch** et **SQLFetchScroll**.<br /><br /> Pour plus d’informations, consultez [liaison des colonnes pour une utilisation avec les curseurs de bloc](../../../odbc/reference/develop-app/binding-columns-for-use-with-block-cursors.md).<br /><br /> Si cet attribut d’instruction définit le champ SQL_DESC_BIND_TYPE dans l’en-tête ARD.|  
|SQL_ATTR_ROW_NUMBER (ODBC 2.0)|Un SQLULEN qui correspond au nombre de la ligne actuelle dans le résultat entier de la valeur. Si le numéro de la ligne actuelle ne peut pas être déterminé ou il n’existe aucune ligne en cours, le pilote retourne 0.<br /><br /> Cet attribut peut être récupéré par un appel à **SQLGetStmtAttr** mais pas défini par un appel à **SQLSetStmtAttr**.|  
|SQL_ATTR_ROW_OPERATION_PTR (ODBC 3.0)|Un SQLUSMALLINT \* valeur pointe vers un tableau de valeurs SQLUSMALLINT utilisé pour ignorer une ligne pendant une opération en bloc à l’aide **SQLSetPos**. Chaque valeur est définie sur SQL_ROW_PROCEED (pour la ligne à inclure dans l’opération en bloc) ou SQL_ROW_IGNORE (pour la ligne à exclure de l’opération en bloc). (Les lignes ne peuvent pas être ignorées à l’aide de ce tableau pendant les appels aux **SQLBulkOperations**.)<br /><br /> Cet attribut d’instruction peut être défini à un pointeur null, dans lequel le cas, le pilote ne retourne pas les valeurs d’état de ligne. Cet attribut peut être défini à tout moment, mais la nouvelle valeur n’est pas utilisée jusqu'à la prochaine **SQLSetPos** est appelée.<br /><br /> Pour plus d’informations, consultez [la mise à jour des lignes dans l’ensemble de lignes avec SQLSetPos](../../../odbc/reference/develop-app/updating-rows-in-the-rowset-with-sqlsetpos.md) et [suppression de lignes dans l’ensemble de lignes avec SQLSetPos](../../../odbc/reference/develop-app/deleting-rows-in-the-rowset-with-sqlsetpos.md).<br /><br /> Si cet attribut d’instruction définit le champ SQL_DESC_ARRAY_STATUS_PTR dans le ARD.|  
|SQL_ATTR_ROW_STATUS_PTR (ODBC 3.0)|Un SQLUSMALLINT \* valeur qui pointe vers un tableau de SQLUSMALLINT valeurs contenant des valeurs état ligne après un appel à **SQLFetch** ou **SQLFetchScroll**. Le tableau a autant d’éléments qu’il existe des lignes dans l’ensemble de lignes.<br /><br /> Cet attribut d’instruction peut être défini à un pointeur null, dans lequel le cas, le pilote ne retourne pas les valeurs d’état de ligne. Cet attribut peut être défini à tout moment, mais la nouvelle valeur n’est pas utilisée jusqu'à la prochaine **SQLBulkOperations**, **SQLFetch**, **SQLFetchScroll**, ou  **SQLSetPos** est appelée.<br /><br /> Pour plus d’informations, consultez [nombre de lignes extraites et état](../../../odbc/reference/develop-app/number-of-rows-fetched-and-status.md).<br /><br /> Si cet attribut d’instruction définit le champ SQL_DESC_ARRAY_STATUS_PTR dans l’en-tête IRD.<br /><br /> Cet attribut est mappé par un 2 ODBC *.x* pilote à la *rgbRowStatus* tableau dans un appel à **SQLExtendedFetch**.|  
|SQL_ATTR_ROWS_FETCHED_PTR (ODBC 3.0)|Un SQLULEN \* valeur pointe vers une mémoire tampon dans lequel retourner le nombre de lignes extraites après un appel à **SQLFetch** ou **SQLFetchScroll**; le nombre de lignes affectées par une opération en bloc effectuées par un appel à **SQLSetPos** avec un *opération* argument de SQL_REFRESH ; ou le nombre de lignes affectées par une opération en bloc effectuée par **SQLBulkOperations**. Ce nombre inclut les lignes d’erreur.<br /><br /> Pour plus d’informations, consultez [nombre de lignes extraites et état](../../../odbc/reference/develop-app/number-of-rows-fetched-and-status.md).<br /><br /> Si cet attribut d’instruction définit le champ SQL_DESC_ROWS_PROCESSED_PTR dans l’en-tête IRD.<br /><br /> Si l’appel à **SQLFetch** ou **SQLFetchScroll** que remplit la mémoire tampon désignée par cet attribut ne retourne pas SQL_SUCCESS ou SQL_SUCCESS_WITH_INFO, le contenu de la mémoire tampon n’est pas défini.|  
|SQL_ATTR_SIMULATE_CURSOR (ODBC 2.0)|Une valeur SQLULEN qui spécifie si les pilotes qui simulent positionnés mettre à jour et supprimer des instructions garantit que ces instructions n'affectent qu’une seule ligne.<br /><br /> Pour simuler la mise à jour positionnée et supprimer des instructions, la plupart des pilotes de construire une recherche **mettre à jour** ou **supprimer** instruction contenant un **où** clause qui spécifie le valeur de chaque colonne dans la ligne actuelle. À moins que ces colonnes composent une clé unique, une telle déclaration peut affecter plusieurs lignes.<br /><br /> Pour garantir que ces instructions n'affectent qu’une seule ligne, le pilote détermine les colonnes d’une clé unique et ajoute ces colonnes au jeu de résultats. Si une application garantit que les colonnes du jeu de résultats constituent une clé unique, le pilote n’est pas obligé de le faire. Ceci peut réduire les temps d’exécution.<br /><br /> SQL_SC_NON_UNIQUE = le pilote ne garantit pas simulant positionné mise à jour ou des instructions de suppression affecteront qu’une seule ligne ; Il est responsable de l’application à le faire. Si une instruction concerne plusieurs lignes, **SQLExecute**, **SQLExecDirect**, ou **SQLSetPos** retourne SQLSTATE 01001 (conflit d’opération de curseur).<br /><br /> SQL_SC_TRY_UNIQUE = le pilote tente de garantir qui simulée positionné mise à jour ou supprimer des instructions affectent qu’une seule ligne. Le pilote exécute toujours ces instructions, même si elles peuvent affecter plusieurs lignes, par exemple quand il n’existe aucune clé unique. Si une instruction concerne plusieurs lignes, **SQLExecute**, **SQLExecDirect**, ou **SQLSetPos** retourne SQLSTATE 01001 (conflit d’opération de curseur).<br /><br /> SQL_SC_UNIQUE = les garanties de pilote simulant la mise à jour positionnée ou de supprimer les instructions affectent qu’une seule ligne. Si le pilote ne peut pas garantir cela pour une instruction donnée, **SQLExecDirect** ou **SQLPrepare** retourne une erreur.<br /><br /> Si la source de données fournit SQL natif prennent en charge pour la mise à jour positionnée et supprimer des instructions et le pilote ne simule pas les curseurs, SQL_SUCCESS est retournée lorsque SQL_SC_UNIQUE est demandé pour SQL_SIMULATE_CURSOR. SQL_SUCCESS_WITH_INFO est retourné si SQL_SC_TRY_UNIQUE ou SQL_SC_NON_UNIQUE est demandée. Si la source de données fournit le niveau SQL_SC_TRY_UNIQUE de prise en charge et le pilote n’effectue pas, la valeur SQL_SUCCESS est retournée pour SQL_SC_TRY_UNIQUE et SQL_SUCCESS_WITH_INFO est retourné pour SQL_SC_NON_UNIQUE.<br /><br /> Si le type de simulation de curseur spécifié n’est pas pris en charge par la source de données, le pilote substitue un type différent de simulation et retourne SQLSTATE 01 s 02 (valeur d’Option modifiée). Pour SQL_SC_UNIQUE, le pilote remplace, dans l’ordre, SQL_SC_TRY_UNIQUE ou SQL_SC_NON_UNIQUE. Pour SQL_SC_TRY_UNIQUE, le pilote remplace SQL_SC_NON_UNIQUE.<br /><br /> La valeur par défaut est SQL_SC_UNIQUE.<br /><br /> Pour plus d’informations, consultez [simulant positionné instructions Update et Delete](../../../odbc/reference/develop-app/simulating-positioned-update-and-delete-statements.md).|  
|SQL_ATTR_USE_BOOKMARKS (ODBC 2.0)|Une valeur SQLULEN qui spécifie si une application doit utiliser des signets avec un curseur :<br /><br /> SQL_UB_OFF = Off (valeur par défaut)<br /><br /> SQL_UB_VARIABLE = une application utiliser des signets avec un curseur, et le pilote fournira des signets de longueur variable, si elles sont prises en charge. SQL_UB_FIXED est déconseillée dans ODBC 3 *.x*. ODBC 3 *.x* applications doivent toujours utiliser des signets de longueur variable, même lorsque vous travaillez avec ODBC 2 *.x* pilotes (qui pris en charge uniquement sur 4 octets, de longueur fixe de signets). Il s’agit d’un signet de longueur fixe étant simplement un cas spécial d’un signet de longueur variable. Lorsque vous travaillez avec un ODBC 2 *.x* pilote, le Gestionnaire de pilotes mappe SQL_UB_VARIABLE à SQL_UB_FIXED.<br /><br /> Pour utiliser des signets avec un curseur, l’application doit spécifier cet attribut avec la valeur SQL_UB_VARIABLE avant l’ouverture du curseur.<br /><br /> Pour plus d’informations, consultez [signets récupération](../../../odbc/reference/develop-app/retrieving-bookmarks.md).|  
  
 [1], ces fonctions peuvent être appelées de façon asynchrone uniquement si le descripteur est un descripteur d’implémentation, pas un descripteur d’application.  
  
 Consultez [la liaison](../../../odbc/reference/develop-app/column-wise-binding.md) et [la liaison](../../../odbc/reference/develop-app/row-wise-binding.md).  
  
## <a name="related-functions"></a>Fonctions connexes  
  
|Pour obtenir des informations sur|Consultez|  
|---------------------------|---------|  
|Annulation de traitement d’instruction|[SQLCancel, fonction](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Retourner le paramètre d’un attribut de connexion|[SQLGetConnectAttr, fonction](../../../odbc/reference/syntax/sqlgetconnectattr-function.md)|  
|Retourner le paramètre d’un attribut d’instruction|[SQLGetStmtAttr, fonction](../../../odbc/reference/syntax/sqlgetstmtattr-function.md)|  
|Définition d’un attribut de connexion|[SQLSetConnectAttr, fonction](../../../odbc/reference/syntax/sqlsetconnectattr-function.md)|  
|Définition d’un champ unique du descripteur|[SQLSetDescField, fonction](../../../odbc/reference/syntax/sqlsetdescfield-function.md)|  
  
## <a name="see-also"></a>Voir aussi  
 [Référence de l’API ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Fichiers d’en-tête ODBC](../../../odbc/reference/install/odbc-header-files.md)
